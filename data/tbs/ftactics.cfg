{
	handlers: {
		start: "[set(doc, construct('game',
		                 {
		         players: map(range(2),
				        construct('player',
				            {
								player_index: value,
							}
				          ))})), seed_rng(),
						  
						  ]",

		add_bot: "[
		  add(me.state_id, 1),
		  debug('ADD BOT: ' + state_id + ' ' + size(bots)),
		  add(bots, [{
			script: [{
				session_id: session_id,
				send: {
					type: 'request_updates'
				}
			}],

			on_create: 'set(data, construct(q(bot_' + bot_type + '), {session_id: ${session_id}, args: ' + str(args) + ' or {}}))',
			on_message: q(data.handle_message(message, me)),

		}]),
		debug('ADD BOT')]",

		message: "[
		 //handle_errors(
		 switch(message.type,
		  'submit_deck',
		  if(message.force or not doc.players[player].deck,
		  [
		  add(me.state_id, 1),
		  set(doc.players, doc.players[:player] + [ new_player ] + doc.players[player+1:]),
		  doc.player_init(new_player)
		  ] where new_player =
		    construct('player',
			  {
				 player_index: player,
				 deck: shuffled_deck[5:],
				 hand: shuffled_deck[0:5],
				 deck_submitted: true,
			  } where shuffled_deck = shuffle(map(message.deck, value))
			)),
		  'moves', [
		    debug('got moves message: ', message),
		  if(player = doc.current_player and message.state_id = state_id, [
			 add(me.state_id, 1),
		     doc.process_moves(map(message.moves, construct('message.' + value.type, value))),
			 bind_command(def(game, tbs_game) if(doc.winner_index != null, set(tbs_game.winner, doc.winner_index)), doc, me),
			],
			 debug('REJECTING MESSAGE FROM PLAYER ' + player + ' STATE ID ' + message.state_id + ' BECAUSE WE ARE PLAYER ' + doc.current_player + ' WITH STATE ID ' + state_id))
		  ]
		),
		 //error handling
		 /*
		 [
		   debug('ERROR WHILE PROCESSING MESSAGE: ' + context.message.type + ': ' + error_msg),
		   context.doc.log_message('Server encountered error when processing ' + message.type)
		 ]
		)
		*/ 
		 ]",

		transform: "[set(message.nplayer, nplayer)]",
	}
}
